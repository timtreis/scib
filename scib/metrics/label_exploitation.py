import numpy as np
import pandas as pd
import anndata as ad
from functools import wraps
import random


def randomly_append_a_or_b(strings: list[str], indices: list[int]) -> list[str]:
    for i in indices:
        strings[i] += "_a" if random.random() < 0.5 else "_b"
    return strings


def access_label_exploitation(function_call):
    @wraps(function_call)
    def wrapper(adata: ad.AnnData, *args, **kwargs):

        label_key = kwargs.get("label_key")
        if label_key is None:
            raise ValueError("The 'label_key' is required.")
        if label_key not in adata.obs.columns:
            raise ValueError(f"'{label_key}' is not a valid key in adata.obs.")

        batch_key = kwargs.get("batch_key")
        if batch_key is None:
            raise ValueError("The 'batch_key' is required.")
        if batch_key not in adata.obs.columns:
            raise ValueError(f"'{batch_key}' is not a valid key in adata.obs.")

        # copy for modification
        adata_renamed = adata.copy()

        # generate _a and _b labels
        new_labels = adata_renamed.obs[label_key].values.tolist()
        for _, group in adata.obs.groupby(batch_key):
            labels = group[label_key].values
            unique_labels = np.unique(labels)

            for label in unique_labels:
                label_indices = group[group[label_key] == label].index.astype(int).tolist()
                new_labels = randomly_append_a_or_b(new_labels, label_indices)

        adata_renamed.obs[label_key] = new_labels

        adata_corrected = function_call(adata, *args, **kwargs)
        adata_renamed_corrected = function_call(adata_renamed, *args, **kwargs)

        return adata_corrected, adata_renamed_corrected

    return wrapper
